package game;

import java.util.LinkedList;

/**
 * Represents the game board for the Snake game.
 * <p>
 * Manages a 2D grid of cells, tracks snake and apple positions,
 * and provides methods to clear and update the board state.
 * </p>
 * javadoc generated by chatgpt. April 25th 2025
 */
public class Board {

    // CELL STATES
    private final int EMPTY = 0;
    private final int SNAKE = 1;
    private final int APPLE = 2;

    private final int rows;
    private final int columns;
    private int[][] grid;

    private LinkedList<int[]> snakeBody;
    private int[] appleBody;

    /**
     * Constructs a new Board with specified dimensions and clears it.
     *
     * @param columns the width of the board (number of columns)
     * @param rows    the height of the board (number of rows)
     * javadoc generated by chatgpt. April 25th 2025
     */
    public Board(int columns, int rows){
        this.columns = columns;
        this.rows = rows;
        this.grid = new int[rows][columns]; // rows = y, columns = x
        clearBoard();
    }

    /**
     * Updates the board by clearing the snake's old tail position,
     * drawing the current snake body, and placing the apple.
     *
     * @param snake the Snake instance whose body to render
     * @param apple the Apple instance whose position to render
     * javadoc generated by chatgpt. April 25th 2025
     */
    public void updateBoard(Snake snake, Apple apple) {

        // wipe only the cell that became empty
        int[] oldTail = snake.getLastRemovedTail();
        if (oldTail != null) {
            setCell(oldTail[0], oldTail[1], EMPTY);
        }

        //  draw snake
        for (int[] part : snake.getBody()) {
            setCell(part[0], part[1], SNAKE);
        }

        // draw apple
        int[] applePos = apple.getApplePosition();
        if (applePos != null) {
            setCell(applePos[0], applePos[1], APPLE);
        }
    }

    /**
     * Resets entire board
     */
    public void clearBoard(){
        for (int y = 0; y < rows; y++){
            for (int x = 0; x < columns; x++) {
                grid[y][x] = EMPTY;
            }
        }
    }

    /**
     * Retrieves state of a specific cell.
     *
     * @param x column index
     * @param y row index
     * @return the state constant (EMPTY, SNAKE, or APPLE)
     */
    public int getCell(int x, int y){
        return grid[y][x];
    }

    /**
     * Sets state of a specific cell.
     *
     * @param x     the column index
     * @param y     the row index
     * @param state the state to set (EMPTY, SNAKE, or APPLE)
     */
    public void setCell(int x, int y, int state){
        grid[y][x] = state;
    }

    /**
     * Returns the number of rows/height of the board.
     *
     * @return total rows
     */
    public int getRows() {
        return rows;
    }

    /**
     * Returns the number of columns/width of the board.
     *
     * @return total columns
     */
    public int getColumns() {
        return columns;
    }

    /**
     * Returns the entire grid array representing board state.
     *
     * @return a 2D array of cell states
     * javadoc generated by chatgpt. April 25th 2025
     */
    public int[][] getGrid(){
        return grid;
    }

    /**
     * Finds and returns the current apple position on the board.
     * <p>
     * Scans the grid for a cell with state APPLE and returns its coordinates.
     * Returns null if no apple is found.
     * </p>
     *
     * @return an {x,y} array of the apple location, or null if none
     * javadoc generated by chatgpt. April 25th 2025
     */
    public int[] getApplePosition(){
        for (int y = 0; y < rows; y++){
            for (int x = 0; x < columns; x++) {
                if (grid[y][x] == APPLE) {
                    return new int[]{x,y};
                }
            }
        }

        return null;
    }

}
