package controllers;

import game.*;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;

import java.net.URL;
import java.util.ResourceBundle;

public class BoardController implements Initializable, EventHandler<KeyEvent> {

    private static final int CELL_SIZE = 30;
    private static final Color EMPTY  = Color.web("2b2d30");
    private static final Color SNAKE  = Color.LIMEGREEN;
    private static final Color SNAKE_HEAD = Color.GOLD;
    private static final Color APPLE  = Color.RED;

    @FXML
    private GridPane boardGrid;

    private SnakeGame snakeGame;
    private Rectangle[][] cells;
    private int rows;
    private int cols;

    /* chatgpt: timeline that drives the game */
    private Timeline clock;

    /**
     * Sets up the board view, configures the game model, and starts the game clock.
     *
     * @param url the location used to resolve relative paths for FXML files
     * @param rb  the resources used for localization
     *
     * javadoc generated by chatgpt. April 26th 2025
     */
    @Override
    public void initialize(URL url, ResourceBundle rb) {

        snakeGame = new SnakeGame();
        rows = snakeGame.getBoardRows();
        cols = snakeGame.getBoardColumns();
        cells = new Rectangle[rows][cols];

        /* lock GridPane size to exact board dimensions */
        double boardSide = cols * CELL_SIZE;           // 20 Ã— 30 = 600
        boardGrid.setMinSize(boardSide, boardSide);
        boardGrid.setMaxSize(boardSide, boardSide);
        HBox.setHgrow(boardGrid, Priority.NEVER);
        boardGrid.getColumnConstraints().clear();
        boardGrid.getRowConstraints().clear();


        /* fixed-pixel column & row constraints */
        for (int c = 0; c < cols; c++) {
            ColumnConstraints cc = new ColumnConstraints(CELL_SIZE);
            cc.setMinWidth(CELL_SIZE);
            cc.setMaxWidth(CELL_SIZE);
            boardGrid.getColumnConstraints().add(cc);
        }
        for (int r = 0; r < rows; r++) {
            RowConstraints rc = new RowConstraints(CELL_SIZE);
            rc.setMinHeight(CELL_SIZE);
            rc.setMaxHeight(CELL_SIZE);
            boardGrid.getRowConstraints().add(rc);
        }

        /* create rectangles for every cell */
        for (int y = 0; y < rows; y++) {
            for (int x = 0; x < cols; x++) {
                Rectangle rect = new Rectangle(CELL_SIZE, CELL_SIZE);
                rect.setFill(EMPTY);
                boardGrid.add(rect, x, y);
                cells[y][x] = rect;
            }
        }

        boardGrid.setGridLinesVisible(true);
        boardGrid.setFocusTraversable(true);
        boardGrid.setOnKeyPressed(this);
        boardGrid.requestFocus();

        snakeGame.getApple().spawn();
        snakeGame.updateBoard();
        paint();

        clock = new Timeline(new KeyFrame(Duration.millis(250), new StepHandler())); // (1s = 1e3 ms)
        clock.setCycleCount(Timeline.INDEFINITE);
        clock.play();
    }

    /**
     * Invoked by the {@link StepHandler} each tick to advance the game one step.
     *
     * javadoc generated by chatgpt. April 26th 2025
     */
    public void nextStep() {
        moveAndRepaint();
    }

    /**
     * Processes player's keyboard inputs to change snake direction
     *
     */
    @Override
    public void handle(KeyEvent e) {
        KeyCode key = e.getCode();

        if (key == KeyCode.W || key == KeyCode.UP) {
            snakeGame.getSnake().changeDirection(Direction.NORTH);
        } else if (key == KeyCode.A || key == KeyCode.LEFT) {
            snakeGame.getSnake().changeDirection(Direction.WEST);
        } else if (key == KeyCode.S || key == KeyCode.DOWN) {
            snakeGame.getSnake().changeDirection(Direction.SOUTH);
        } else if (key == KeyCode.D || key == KeyCode.RIGHT) {
            snakeGame.getSnake().changeDirection(Direction.EAST);
        }

        // todo: add pause game feature

    }

    /**
     * Advances the game state and repaints the board.
     * Stops early if the snake dies.
     */
    private void moveAndRepaint() {
        snakeGame.moveSnake();

        if (snakeGame.checkCollision()) {
            return;
        }

        snakeGame.checkAppleEat();
        snakeGame.updateBoard();
        paint();
    }

    /**
     * Updates representation of every cell based on the game grid.
     */
    private void paint() {

        int[] headPos = snakeGame.getSnake().getBody().get(0);

        int[][] grid = snakeGame.getGrid();

        for (int y = 0; y < rows; y++) {
            for (int x = 0; x < cols; x++) {

                // snake head gets different colour
                if (x == headPos[0] && y == headPos[1]) {
                    cells[y][x].setFill(SNAKE_HEAD);
                    continue;
                }

                switch (grid[y][x]) {
                    case 1 -> cells[y][x].setFill(SNAKE);
                    case 2 -> cells[y][x].setFill(APPLE);
                    default -> cells[y][x].setFill(EMPTY);
                }
            }
        }
    }

    private class StepHandler implements EventHandler<ActionEvent> {

        /**
         * Called by the JavaFX timeline every tick to trigger a game update.
         *
         * @param event the action event fired by the timeline
         *
         * javadoc generated by chatgpt. April 26th 2025
         */
        @Override
        public void handle(ActionEvent event) {
            nextStep();
        }
    }

}
